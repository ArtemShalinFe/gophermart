
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/config/config.go (0.0%)</option>
				
				<option value="file1">github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/models/order.go (13.3%)</option>
				
				<option value="file2">github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/models/user.go (66.7%)</option>
				
				<option value="file3">github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/server/handlers.go (60.5%)</option>
				
				<option value="file4">github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/server/jwt.go (87.5%)</option>
				
				<option value="file5">github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/server/logger.go (81.8%)</option>
				
				<option value="file6">github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/server/mock_handlers.go (61.5%)</option>
				
				<option value="file7">github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/server/server.go (73.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "github.com/spf13/pflag"
        "github.com/spf13/viper"
)

type Config struct {
        Address string
        Accrual string
        DSN     string
        Key     []byte
}

const envAddress = "RUN_ADDRESS"
const envDSN = "DATABASE_URI"
const envAccrualAddress = "ACCRUAL_SYSTEM_ADDRESS"
const envSecretKey = "KEY"

func GetConfig() *Config <span class="cov0" title="0">{
        c := &amp;Config{}

        var key string
        pflag.StringVarP(&amp;c.Address, "address", "a", "", "Gophermart-service address and port")
        pflag.StringVarP(&amp;c.Accrual, "accrual", "r", "", "Accrual-service address and port")
        pflag.StringVarP(&amp;c.DSN, "dsn", "d", "", "Postgresql DSN string")
        pflag.StringVarP(&amp;key, "key", "k", "", "Secret key")
        pflag.Parse()

        viper.AutomaticEnv()
        viper.SetDefault(envAddress, "localhost:8078")
        viper.SetDefault(envDSN, "")
        viper.SetDefault(envAccrualAddress, "localhost:8080")
        viper.SetDefault(envSecretKey, "gophermart")

        if c.Address == "" </span><span class="cov0" title="0">{
                c.Address = viper.GetString(envAddress)
        }</span>

        <span class="cov0" title="0">if c.DSN == "" </span><span class="cov0" title="0">{
                c.DSN = viper.GetString(envDSN)
        }</span>

        <span class="cov0" title="0">if c.Accrual == "" </span><span class="cov0" title="0">{
                c.Accrual = viper.GetString(envAccrualAddress)
        }</span>

        <span class="cov0" title="0">if key == "" </span><span class="cov0" title="0">{
                key = viper.GetString(envSecretKey)
        }</span>
        <span class="cov0" title="0">c.Key = []byte(key)

        return c</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package models

import (
        "context"
        "errors"
        "fmt"
        "time"
)

type OrderDTO struct {
        UserID string `json:"userId"`
        Number int64  `json:"number"`
}

const OrderStatusNew = "NEW"
const OrderStatusProcessing = "PROCESSING"
const OrderStatusInvalid = "INVALID"
const OrderStatusProcessed = "PROCESSED"

type Order struct {
        UploadedAt time.Time `json:"uploaded_at"`
        ID         string    `json:"uuid"`
        UserID     string    `json:"userId"`
        Status     string    `json:"status"`
        Accrual    int64     `json:"accrual"`
        Number     int64     `json:"number"`
}

type OrderStorage interface {
        AddOrder(ctx context.Context, order *OrderDTO) (*Order, error)
        GetOrder(ctx context.Context, order *OrderDTO) (*Order, error)
        GetOrdersForAccrual(ctx context.Context) ([]*Order, error)
        UpdateOrder(ctx context.Context, order *Order) error
}

type AccrualService interface {
        GetOrderAccrual(ctx context.Context, order *Order) (*OrderAccrual, error)
}

var ErrOrderWasRegisteredEarlier = errors.New("the order was registered earlier")

func (o *OrderDTO) AddOrder(ctx context.Context, db OrderStorage) (*Order, error) <span class="cov8" title="1">{
        return db.AddOrder(ctx, o)
}</span>

func (o *OrderDTO) GetOrder(ctx context.Context, db OrderStorage) (*Order, error) <span class="cov8" title="1">{
        return db.GetOrder(ctx, o)
}</span>

func (o *Order) Update(ctx context.Context, db OrderStorage) error <span class="cov0" title="0">{
        return db.UpdateOrder(ctx, o)
}</span>

func RunOrdersAccrual(ctx context.Context, a AccrualService, db OrderStorage) error <span class="cov0" title="0">{
        ors, err := db.GetOrdersForAccrual(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get orders for accrual failed err: %w", err)
        }</span>

        <span class="cov0" title="0">for _, o := range ors </span><span class="cov0" title="0">{
                oa, err := a.GetOrderAccrual(ctx, o)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("get order accrual failed err: %w", err)
                }</span>

                <span class="cov0" title="0">o.Status = oa.Status
                o.Accrual = oa.Accrual

                if err := o.Update(ctx, db); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("update order failed err: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package models

import (
        "context"
        "encoding/base64"
        "errors"
)

type UserDTO struct {
        Login    string `json:"login"`
        Password string `json:"password"`
}

type User struct {
        ID             string `json:"uuid"`
        Login          string `json:"login"`
        PasswordBase64 string `json:"password"`
}

var ErrLoginIsBusy = errors.New("login is busy")
var ErrUnknowUser = errors.New("unknow user")

type UserStorage interface {
        AddUser(ctx context.Context, us *UserDTO) (*User, error)
        GetUser(ctx context.Context, us *UserDTO) (*User, error)
        GetUploadedOrders(ctx context.Context, us *User) ([]*Order, error)
}

func (u *UserDTO) AddUser(ctx context.Context, db UserStorage) (*User, error) <span class="cov8" title="1">{
        return db.AddUser(ctx, u)
}</span>

func (u *UserDTO) GetUser(ctx context.Context, db UserStorage) (*User, error) <span class="cov8" title="1">{
        if u.Login == "" </span><span class="cov0" title="0">{
                return nil, ErrUnknowUser
        }</span>

        <span class="cov8" title="1">return db.GetUser(ctx, u)</span>
}

func (o *User) GetUploadedOrders(ctx context.Context, db UserStorage) ([]*Order, error) <span class="cov0" title="0">{
        return db.GetUploadedOrders(ctx, o)
}</span>

func EncodePassword(password string) string <span class="cov8" title="1">{
        return base64.StdEncoding.EncodeToString([]byte(password))
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package server

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strconv"

        "github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/models"
        "go.uber.org/zap"
)

type Storage interface {
        AddUser(ctx context.Context, us *models.UserDTO) (*models.User, error)
        GetUser(ctx context.Context, us *models.UserDTO) (*models.User, error)
        GetUploadedOrders(ctx context.Context, order *models.User) ([]*models.Order, error)
        GetOrdersForAccrual(ctx context.Context) ([]*models.Order, error)
        AddOrder(ctx context.Context, order *models.OrderDTO) (*models.Order, error)
        GetOrder(ctx context.Context, order *models.OrderDTO) (*models.Order, error)
        UpdateOrder(ctx context.Context, order *models.Order) error
}

const authHeaderName = "Authorization"

type Handlers struct {
        log       *zap.SugaredLogger
        store     Storage
        secretKey []byte
}

func NewHandlers(secretKey []byte, db Storage, log *zap.SugaredLogger) (*Handlers, error) <span class="cov8" title="1">{
        return &amp;Handlers{
                store:     db,
                secretKey: secretKey,
                log:       log,
        }, nil
}</span>

func (h *Handlers) Register(ctx context.Context, w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        u, err := getLoginPsw(w, r)
        if err != nil </span><span class="cov8" title="1">{
                h.log.Errorf("failed to read the Register request body err: %w ", err)
                return
        }</span>

        <span class="cov8" title="1">if _, err = u.AddUser(ctx, h.store); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrLoginIsBusy) </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusConflict)
                        return
                }</span>

                <span class="cov0" title="0">h.log.Errorf("failed add user in the Register request err: %w ", err)
                w.WriteHeader(http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">token, err := NewJWTToken(h.secretKey, u.Login, u.Password)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Errorf("failed to build JWT token in the Register request err: %w ", err)
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set(authHeaderName, token)
        w.WriteHeader(http.StatusOK)</span>
}

func (h *Handlers) Login(ctx context.Context, w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        u, err := getLoginPsw(w, r)
        if err != nil </span><span class="cov8" title="1">{
                h.log.Errorf("failed to read the Login request body err: %w ", err)
                return
        }</span>

        <span class="cov8" title="1">_, err = u.GetUser(ctx, h.store)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, models.ErrUnknowUser) </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">h.log.Errorf("failed in the Register request err: %w ", err)
                w.WriteHeader(http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">token, err := NewJWTToken(h.secretKey, u.Login, u.Password)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set(authHeaderName, token)
        w.WriteHeader(http.StatusOK)</span>
}

func (h *Handlers) AddOrder(ctx context.Context, w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        u, err := h.GetUserFromJWTToken(w, r)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                h.log.Errorf("failed to get user from JWT in the AddOrder request err: %w ", err)
                return
        }</span>

        <span class="cov8" title="1">b, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                h.log.Errorf("failed to read the AddOrder request body err: %w ", err)
                return
        }</span>

        <span class="cov8" title="1">number, err := strconv.ParseInt(string(b), 0, 64)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                h.log.Errorf("failed to convert in the AddOrder request err: %w ", err)
                return
        }</span>

        <span class="cov8" title="1">o := &amp;models.OrderDTO{
                Number: number,
                UserID: u.ID,
        }

        if _, err = o.AddOrder(ctx, h.store); err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, models.ErrOrderWasRegisteredEarlier) </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        h.log.Errorf("failed to add order in the AddOrder request err: %w ", err)
                        return
                }</span>

                <span class="cov8" title="1">o, err := o.GetOrder(ctx, h.store)
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        h.log.Errorf("failed to get the order the AddOrder request body err: %w ", err)
                        return
                }</span>

                <span class="cov8" title="1">if o.UserID != u.ID </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusConflict)
                        return
                }</span> else<span class="cov8" title="1"> {
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusAccepted)</span>
}

func (h *Handlers) GetOrders(ctx context.Context, w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.log.Info("GetOrders not implemented")
}</span>

func (h *Handlers) GetBalance(ctx context.Context, w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.log.Info("GetBalance not implemented")
}</span>

func (h *Handlers) AddBalanceWithdraw(ctx context.Context, w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.log.Info("AddBalanceWithdraw not implemented")
}</span>

func (h *Handlers) GetWithdrawals(ctx context.Context, w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        h.log.Info("GetWithdrawals not implemented")
}</span>

func getLoginPsw(w http.ResponseWriter, r *http.Request) (*models.UserDTO, error) <span class="cov8" title="1">{
        var u models.UserDTO

        b, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                return nil, fmt.Errorf("failed get login and pass from body err: %w", err)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(b, &amp;u); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                return nil, fmt.Errorf("failed unmarhsal login and pass err: %w", err)
        }</span>

        <span class="cov8" title="1">if u.Login == "" </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusBadRequest)
                return nil, errors.New("bad request")
        }</span>

        <span class="cov8" title="1">u.Password = models.EncodePassword(u.Password)

        return &amp;u, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package server

import (
        "fmt"
        "net/http"
        "time"

        "github.com/golang-jwt/jwt/v4"

        "github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/models"
)

type Claims struct {
        jwt.RegisteredClaims
        Login    string
        Password string
}

func NewJWTToken(secretKey []byte, login string, password string) (string, error) <span class="cov8" title="1">{
        const tokenExp = time.Hour * 1

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, Claims{
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(tokenExp)),
                },
                Login:    login,
                Password: password,
        })

        tokenString, err := token.SignedString(secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}

func IsAuthorized(tokenString string, secretKey []byte) (bool, error) <span class="cov8" title="1">{
        claims := &amp;Claims{}

        token, err := jwt.ParseWithClaims(tokenString, claims,
                func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov8" title="1">return secretKey, nil</span>
                })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("token parse err: %w", err)
        }</span>

        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return false, fmt.Errorf("token is invalid: %w", err)
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

func (h *Handlers) GetUserFromJWTToken(w http.ResponseWriter, r *http.Request) (*models.User, error) <span class="cov8" title="1">{
        authToken := r.Header.Get(authHeaderName)

        claims := &amp;Claims{}
        _, err := jwt.ParseWithClaims(authToken, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return h.secretKey, nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GetUserFromJWTToken error: %w", err)
        }</span>

        <span class="cov8" title="1">udto := models.UserDTO{
                Login:    claims.Login,
                Password: claims.Password,
        }

        return udto.GetUser(r.Context(), h.store)</span>
}

func (h *Handlers) JwtMiddleware(hr http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                authToken := r.Header.Get(authHeaderName)

                authorized, err := IsAuthorized(authToken, h.secretKey)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">if authorized </span><span class="cov8" title="1">{
                        hr.ServeHTTP(w, r)
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package server

import (
        "bytes"
        "io"
        "net/http"
        "time"
)

func (h *Handlers) RequestLogger(hr http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                rw := NewResponseLoggerWriter(w)

                var buf bytes.Buffer

                tee := io.TeeReader(r.Body, &amp;buf)
                body, err := io.ReadAll(tee)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Internal server error", http.StatusInternalServerError)
                        h.log.Errorf("request logger read body err: %w", err)
                        return
                }</span>
                <span class="cov8" title="1">r.Body = io.NopCloser(&amp;buf)

                start := time.Now()
                hr.ServeHTTP(rw, r)
                duration := time.Since(start)

                h.log.Infof("HTTP request method: %s, header: %v, body: %s, url: %s, duration: %s, statusCode: %d, responseSize: %d",
                        r.Method, r.Header, string(body), r.RequestURI, duration, rw.responseData.status, rw.responseData.size,
                )</span>
        })
}

type responseData struct {
        status int
        size   int
}

type ResponseLoggerWriter struct {
        http.ResponseWriter
        responseData *responseData
}

func NewResponseLoggerWriter(w http.ResponseWriter) *ResponseLoggerWriter <span class="cov8" title="1">{
        return &amp;ResponseLoggerWriter{
                ResponseWriter: w,
                responseData:   &amp;responseData{},
        }
}</span>

func (r *ResponseLoggerWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        size, err := r.ResponseWriter.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">r.responseData.size += size

        return size, nil</span>
}

func (r *ResponseLoggerWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        r.ResponseWriter.WriteHeader(statusCode)
        r.responseData.status = statusCode
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: cmd/gophermart/internal/server/handlers.go

// Package server is a generated GoMock package.
package server

import (
        context "context"
        reflect "reflect"

        models "github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/models"
        gomock "go.uber.org/mock/gomock"
)

// MockStorage is a mock of Storage interface.
type MockStorage struct {
        ctrl     *gomock.Controller
        recorder *MockStorageMockRecorder
}

// MockStorageMockRecorder is the mock recorder for MockStorage.
type MockStorageMockRecorder struct {
        mock *MockStorage
}

// NewMockStorage creates a new mock instance.
func NewMockStorage(ctrl *gomock.Controller) *MockStorage <span class="cov8" title="1">{
        mock := &amp;MockStorage{ctrl: ctrl}
        mock.recorder = &amp;MockStorageMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStorage) EXPECT() *MockStorageMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddOrder mocks base method.
func (m *MockStorage) AddOrder(ctx context.Context, order *models.OrderDTO) (*models.Order, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddOrder", ctx, order)
        ret0, _ := ret[0].(*models.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddOrder indicates an expected call of AddOrder.
func (mr *MockStorageMockRecorder) AddOrder(ctx, order interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddOrder", reflect.TypeOf((*MockStorage)(nil).AddOrder), ctx, order)
}</span>

// AddUser mocks base method.
func (m *MockStorage) AddUser(ctx context.Context, us *models.UserDTO) (*models.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddUser", ctx, us)
        ret0, _ := ret[0].(*models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddUser indicates an expected call of AddUser.
func (mr *MockStorageMockRecorder) AddUser(ctx, us interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddUser", reflect.TypeOf((*MockStorage)(nil).AddUser), ctx, us)
}</span>

// GetOrder mocks base method.
func (m *MockStorage) GetOrder(ctx context.Context, order *models.OrderDTO) (*models.Order, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOrder", ctx, order)
        ret0, _ := ret[0].(*models.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetOrder indicates an expected call of GetOrder.
func (mr *MockStorageMockRecorder) GetOrder(ctx, order interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrder", reflect.TypeOf((*MockStorage)(nil).GetOrder), ctx, order)
}</span>

// GetOrdersForAccrual mocks base method.
func (m *MockStorage) GetOrdersForAccrual(ctx context.Context) ([]*models.Order, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOrdersForAccrual", ctx)
        ret0, _ := ret[0].([]*models.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetOrdersForAccrual indicates an expected call of GetOrdersForAccrual.
func (mr *MockStorageMockRecorder) GetOrdersForAccrual(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrdersForAccrual", reflect.TypeOf((*MockStorage)(nil).GetOrdersForAccrual), ctx)
}</span>

// GetUploadedOrders mocks base method.
func (m *MockStorage) GetUploadedOrders(ctx context.Context, order *models.User) ([]*models.Order, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUploadedOrders", ctx, order)
        ret0, _ := ret[0].([]*models.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUploadedOrders indicates an expected call of GetUploadedOrders.
func (mr *MockStorageMockRecorder) GetUploadedOrders(ctx, order interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUploadedOrders", reflect.TypeOf((*MockStorage)(nil).GetUploadedOrders), ctx, order)
}</span>

// GetUser mocks base method.
func (m *MockStorage) GetUser(ctx context.Context, us *models.UserDTO) (*models.User, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", ctx, us)
        ret0, _ := ret[0].(*models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockStorageMockRecorder) GetUser(ctx, us interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockStorage)(nil).GetUser), ctx, us)
}</span>

// UpdateOrder mocks base method.
func (m *MockStorage) UpdateOrder(ctx context.Context, order *models.Order) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateOrder", ctx, order)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateOrder indicates an expected call of UpdateOrder.
func (mr *MockStorageMockRecorder) UpdateOrder(ctx, order interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOrder", reflect.TypeOf((*MockStorage)(nil).UpdateOrder), ctx, order)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package server

import (
        "context"
        "net/http"

        "github.com/go-chi/chi"
        "github.com/go-chi/chi/middleware"
        "go.uber.org/zap"

        "github.com/ArtemShalinFe/gophermart/cmd/gophermart/internal/config"
)

type Server struct {
        HTTPServer *http.Server
        Log        *zap.SugaredLogger
}

func InitServer(h *Handlers, cfg *config.Config, log *zap.SugaredLogger) *Server <span class="cov0" title="0">{
        return &amp;Server{
                HTTPServer: &amp;http.Server{
                        Addr:    cfg.Address,
                        Handler: initRouter(h),
                },
                Log: log,
        }
}</span>

func initRouter(h *Handlers) *chi.Mux <span class="cov8" title="1">{
        router := chi.NewRouter()
        router.Use(middleware.Recoverer)
        router.Use(h.RequestLogger)

        router.Route("/api/user", func(r chi.Router) </span><span class="cov8" title="1">{
                r.Post("/register", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        h.Register(r.Context(), w, r)
                }</span>)

                <span class="cov8" title="1">r.Post("/login", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        h.Login(r.Context(), w, r)
                }</span>)

                <span class="cov8" title="1">r.Group(func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Use(h.JwtMiddleware)

                        r.Post("/orders", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                                h.AddOrder(r.Context(), w, r)
                        }</span>)

                        <span class="cov8" title="1">r.Get("/orders", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                h.GetOrders(r.Context(), w, r)
                        }</span>)

                        <span class="cov8" title="1">r.Get("/balance", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                h.GetBalance(r.Context(), w, r)
                        }</span>)

                        <span class="cov8" title="1">r.Post("/balance/withdraw", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                h.AddBalanceWithdraw(r.Context(), w, r)
                        }</span>)

                        <span class="cov8" title="1">r.Get("/withdrawals", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                h.GetWithdrawals(r.Context(), w, r)
                        }</span>)
                })
        })
        <span class="cov8" title="1">return router</span>
}

func (s *Server) RunOrderAccruals(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
